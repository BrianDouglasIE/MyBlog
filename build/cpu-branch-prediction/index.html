<!doctype html>
<html lang="en">
    <head>
        <!-- Google tag (gtag.js) -->
        <script
            async
            src="https://www.googletagmanager.com/gtag/js?id=G-SXTREFVFLB"
        ></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() {
                dataLayer.push(arguments);
            }
            gtag("js", new Date());

            gtag("config", "G-SXTREFVFLB");
        </script>

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />

        <!-- Meta Description -->
        <meta name="description" content="Using CPU branch prediction in Java" />

        <!-- Keywords -->
        <meta
            name="keywords"
            content="Brian Douglas, blog, java"
        />

        <!-- Author -->
        <meta name="author" content="Brian Douglas" />

        <!-- Open Graph / Facebook -->
        <meta property="og:type" content="website" />
        <meta
            property="og:title"
            content="BrianDouglas.ie - Using CPU branch prediction in Java"
        />
        <meta property="og:description" content="Using CPU branch prediction in Java" />
        <meta property="og:url" content="https://www.briandouglas.ie" />
        <meta
            property="og:image"
            content="http://www.briandouglas.ie/images/og-images/cpu-branch-prediction.png"
        />
        <meta property="og:image:type" content="image/png" />
        <meta property="og:image:width" content="1280" />
        <meta property="og:image:height" content="640" />
        <meta property="og:site_name" content="BrianDouglas.ie" />
        <meta
            property="og:image:alt"
            content="A preview image for the post titled 'Using CPU branch prediction in Java'"
        />

        <!-- Twitter Meta -->
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:site" content="@BrianDouglasIE" />
        <meta
            name="twitter:title"
            content="BrianDouglas.ie - Using CPU branch prediction in Java"
        />
        <meta name="twitter:description" content="Using CPU branch prediction in Java" />
        <meta
            name="twitter:image"
            content="http://www.briandouglas.ie/images/og-images/cpu-branch-prediction.png"
        />

        <!-- Canonical URL -->
        <link rel="canonical" href="https://www.briandouglas.ie" />

        <!-- Favicon (Optional) -->
        <link
            rel="icon"
            href="https://www.briandouglas.ie/favicon.ico"
            type="image/x-icon"
        />

        <!-- Robots -->
        <meta name="robots" content="index, follow" />

        <!-- Favicon-->
        <link
            rel="apple-touch-icon"
            sizes="180x180"
            href="/apple-touch-icon.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="32x32"
            href="/favicon-32x32.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="16x16"
            href="/favicon-16x16.png"
        />
        <link rel="manifest" href="/site.webmanifest" />

        <title>Using CPU branch prediction in Java</title>
        <link rel="stylesheet" href="/styles.css" />
        <style>
            pre code.hljs {
                display: block;
                overflow-x: auto;
                padding: 1em;
            }
            code.hljs {
                padding: 3px 5px;
            }
            .hljs {
                color: #24292e;
                background: #ffffff;
            }
            .hljs-doctag,
            .hljs-keyword,
            .hljs-meta .hljs-keyword,
            .hljs-template-tag,
            .hljs-template-variable,
            .hljs-type,
            .hljs-variable.language_ {
                color: #d73a49;
            }
            .hljs-title,
            .hljs-title.class_,
            .hljs-title.class_.inherited__,
            .hljs-title.function_ {
                color: #6f42c1;
            }
            .hljs-attr,
            .hljs-attribute,
            .hljs-literal,
            .hljs-meta,
            .hljs-number,
            .hljs-operator,
            .hljs-selector-attr,
            .hljs-selector-class,
            .hljs-selector-id,
            .hljs-variable {
                color: #005cc5;
            }
            .hljs-meta .hljs-string,
            .hljs-regexp,
            .hljs-string {
                color: #032f62;
            }
            .hljs-built_in,
            .hljs-symbol {
                color: #e36209;
            }
            .hljs-code,
            .hljs-comment,
            .hljs-formula {
                color: #6a737d;
            }
            .hljs-name,
            .hljs-quote,
            .hljs-selector-pseudo,
            .hljs-selector-tag {
                color: #22863a;
            }
            .hljs-subst {
                color: #24292e;
            }
            .hljs-section {
                color: #005cc5;
                font-weight: bold;
            }
            .hljs-bullet {
                color: #735c0f;
            }
            .hljs-emphasis {
                color: #24292e;
                font-style: italic;
            }
            .hljs-strong {
                color: #24292e;
                font-weight: bold;
            }
            .hljs-addition {
                color: #22863a;
                background-color: #f0fff4;
            }
            .hljs-deletion {
                color: #b31d28;
                background-color: #ffeef0;
            }
            .hljs-char.escape_,
            .hljs-link,
            .hljs-params,
            .hljs-property,
            .hljs-punctuation,
            .hljs-tag {
            }
        </style>
    </head>
    <body>
        <div class="content">
            <header class="site-header">
    <a href="/" class="home">Brian Douglas</a>

    <div class="svg-container">
        <a href="https://github.com/BrianDouglasIE" class="github">
            <svg
                height="32"
                aria-hidden="true"
                viewBox="0 0 24 24"
                width="32"
                data-view-component="true"
            >
                <path
                    d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"
                ></path>
            </svg>
        </a>

        <a
            href="https://linkedin.com/in/brian-douglas-90abb93ab"
            class="linkedin"
        >
            <svg
                viewBox="0 0 128 128"
                height="32"
                aria-hidden="true"
                width="32"
                data-view-component="true"
            >
                <path
                    d="M116 3H12a8.91 8.91 0 00-9 8.8v104.42a8.91 8.91 0 009 8.78h104a8.93 8.93 0 009-8.81V11.77A8.93 8.93 0 00116 3zM39.17 107H21.06V48.73h18.11zm-9-66.21a10.5 10.5 0 1110.49-10.5 10.5 10.5 0 01-10.54 10.48zM107 107H88.89V78.65c0-6.75-.12-15.44-9.41-15.44s-10.87 7.36-10.87 15V107H50.53V48.73h17.36v8h.24c2.42-4.58 8.32-9.41 17.13-9.41C103.6 47.28 107 59.35 107 75z"
                ></path>
            </svg>
        </a>
    </div>
</header>

            <div class="breadcrumbs">
                <a href="/">Home</a> / <span>Using CPU branch prediction in Java</span>
            </div>

            <main>
                <article class="post">
                    <header>
                        <h1>Using CPU branch prediction in Java</h1>
                        <time datetime="03/04/2025"
                            >April 3rd, 2025</time
                        >
                    </header>

                    <div class="body"><p>CPU branch prediction is when the CPU tries to guess the outcome of a conditional
operation, eg: an <code>if</code> statement, before it is executed. If it guesses correct then
the CPU can continue executing instructions without interuption.</p>
<!-- more -->
<p>When applied to Java this can be used to get a performance benefit. In particular
when looping through a large array that runs some condtional operation on each value.</p>
<p><chicken-asks>So how do you make loop conditionals predictable?</chicken-asks>
<magpie-replies>Well we could sort the array before processing it</magpie-replies></p>
<p>Sorting the values of an array before processing it will help with CPU branch prediction.
It may also help with cpu cache optimisation. CPU cache optimisation being the accessing
of data that from the CPU cache. This is memory located close to the CPU cores, data accessed
from here is often processed much quicker than from the main memory. This can be done in Java
by accessing data from a sorted array. The idea being that sorted data may be held closer together
in memory, and therefore can be accessed more quickly, providing a performance benefit.</p>
<h2 id="exampleusage">Example Usage</h2>
<p>Let's see this in action with some example code. Given the following program, the sorted array will be
processed roughly 4 times faster than the unsorted array.</p>
<pre class="java language-java"><code class="hljs java language-java"><span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">arraySize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10_000_000</span>;

        <span class="hljs-type">int</span>[] sortedArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arraySize];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arraySize; i++) {
            sortedArray[i] = i;
        }

        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.nanoTime();
        <span class="hljs-type">long</span> <span class="hljs-variable">sortedSum</span> <span class="hljs-operator">=</span> evenNumberSum(sortedArray);
        <span class="hljs-type">long</span> <span class="hljs-variable">sortedTime</span> <span class="hljs-operator">=</span> System.nanoTime() - startTime;

        <span class="hljs-type">int</span>[] shuffledArray = shuffle(sortedArray);
        startTime = System.nanoTime();
        <span class="hljs-type">long</span> <span class="hljs-variable">unsortedSum</span> <span class="hljs-operator">=</span> evenNumberSum(shuffledArray);
        <span class="hljs-type">long</span> <span class="hljs-variable">unsortedTime</span> <span class="hljs-operator">=</span> System.nanoTime() - startTime;

        <span class="hljs-keyword">if</span> (unsortedSum != sortedSum) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;sortedSum and unsortedSum should match&quot;</span>);
        }

        System.out.println(<span class="hljs-string">&quot;Sorted array processing time:   &quot;</span> + sortedTime + <span class="hljs-string">&quot; ns&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;Unsorted array processing time: &quot;</span> + unsortedTime + <span class="hljs-string">&quot; ns&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;Times faster: &quot;</span> + Math.floorDiv(unsortedTime, sortedTime));
    }

    <span class="hljs-comment">/**
     * Returns a clone of the array with it&#x27;s values shuffled.
     *
     * <span class="hljs-doctag">@param</span> srcArray
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] shuffle(<span class="hljs-type">int</span>[] srcArray) {
        <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();
        <span class="hljs-type">int</span>[] array = srcArray.clone();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
            <span class="hljs-type">int</span> <span class="hljs-variable">randIndex</span> <span class="hljs-operator">=</span> rand.nextInt(i + <span class="hljs-number">1</span>);
            <span class="hljs-type">int</span> <span class="hljs-variable">randIndexValue</span> <span class="hljs-operator">=</span> array[randIndex];
            array[randIndex] = array[i];
            array[i] = randIndexValue;
        }

        <span class="hljs-keyword">return</span> array;
    }

    <span class="hljs-comment">/**
     * Returns the sum of all the even numbers in the array.
     *
     * <span class="hljs-doctag">@param</span> array
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">evenNumberSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> {
        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : array) {
            <span class="hljs-keyword">if</span> (isEven(value)) {
                sum += value;
            }
        }
        <span class="hljs-keyword">return</span> sum;
    }

    <span class="hljs-comment">/**
     * Returns true if n is even and false if not.
     *
     * <span class="hljs-doctag">@param</span> n
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEven</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {
        <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
    }
}
</code></pre>
<p>The above program creates an array of 10 million ints, sorted. It then iterates through that array to get
the sum of all the even ints, measuring the execution time. It then does the same thing with a shuffled
version of the initial sorted array. Running the program you should see that the sorted array is processed
much quicker than the unsorted array. Demonstrating the advantage of CPU branch prediction and cache optimisation.
Below is the result I get when running it locally.</p>
<pre><code class="hljs">Sorted<span class="hljs-built_in"> array </span>processing time:   8745547 ns
Unsorted<span class="hljs-built_in"> array </span>processing time: 37145149 ns
Times faster: 4
</code></pre>
<h2 id="drawbacks">Drawbacks</h2>
<p>While I can't think of a drawback, other than the time spent sorting the array before processing it. There is
a caveat. It may not always give a benefit.</p>
<p>For example, if when processing the array, you ran something that wasn't easily predictable, eg: testing if a
number is a prime, you may not see much difference. While the sorted array would still be more <em>predictable</em>,
in practice the benefit of the prediction would be less significant as the majority of the numbers are likely
non prime and the check would fail early. So there will likely be use cases where you see a great benefit from
processing a sorted array, and some cases there you don't really see any benefit.</p>
<h2 id="summary">Summary</h2>
<p>Sorted arrays in Java benefit from CPU branch prediction and cache optimisation due to predictable
patterns and memory location.</p>
<p>In contrast, unsorted arrays suffer from the lack of predictability and random
memory access patterns.</p></div>

                    <footer>
                        <p><i>Until next time,</i></p>
                        <p><i>Brian</i></p>
                    </footer>
                </article>
            </main>

            <footer class="site-footer">
    <p>
        <small>Since August 4th, 2023. All words by Brian
            Douglas. <a href="mailto:brianwdouglas@proton.me">Have a comment?</a></small>
    </p>
</footer>

        </div>

        <script src="/scripts/chicken-and-magpie.js"></script>
        <script src="/scripts/skip-to-section.js"></script>
    </body>
</html>
