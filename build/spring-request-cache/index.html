<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

    <!-- Meta Description -->
    <meta name="description" content="Request cache in Spring"/>

    <!-- Keywords -->
    <meta name="keywords" content="Brian Douglas, blog, spring,java"/>

    <!-- Author -->
    <meta name="author" content="Brian Douglas"/>

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website"/>
    <meta property="og:title" content="BrianDouglas.ie - Request cache in Spring"/>
    <meta property="og:description" content="Request cache in Spring"/>
    <meta property="og:url" content="https://www.briandouglas.ie"/>
    <meta property="og:image" content="http://www.briandouglas.ie/images/og-images/spring-request-cache.png"/>
    <meta property="og:image:type" content="image/png"/>
    <meta property="og:image:width" content="1280"/>
    <meta property="og:image:height" content="640"/>
    <meta property="og:site_name" content="BrianDouglas.ie"/>
    <meta property="og:image:alt" content="A preview image for the post titled 'Request cache in Spring'"/>

    <!-- Twitter Meta -->
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:site" content="@BrianDouglasIE"/>
    <meta name="twitter:title" content="BrianDouglas.ie - Request cache in Spring"/>
    <meta name="twitter:description" content="Request cache in Spring"/>
    <meta name="twitter:image" content="http://www.briandouglas.ie/images/og-images/spring-request-cache.png"/>

    <!-- Canonical URL -->
    <link rel="canonical" href="https://www.briandouglas.ie"/>

    <!-- Favicon (Optional) -->
    <link rel="icon" href="https://www.briandouglas.ie/favicon.ico" type="image/x-icon"/>

    <!-- Robots -->
    <meta name="robots" content="index, follow"/>

    <!-- Favicon-->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/>
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/>
    <link rel="manifest" href="/site.webmanifest"/>

    <title>Request cache in Spring</title>
    <link rel="stylesheet" href="/styles.css">
    <style>
pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#24292e;background:#ffffff}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#d73a49}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#6f42c1}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-variable{color:#005cc5}.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#032f62}.hljs-built_in,.hljs-symbol{color:#e36209}.hljs-code,.hljs-comment,.hljs-formula{color:#6a737d}.hljs-name,.hljs-quote,.hljs-selector-pseudo,.hljs-selector-tag{color:#22863a}.hljs-subst{color:#24292e}.hljs-section{color:#005cc5;font-weight:bold}.hljs-bullet{color:#735c0f}.hljs-emphasis{color:#24292e;font-style:italic}.hljs-strong{color:#24292e;font-weight:bold}.hljs-addition{color:#22863a;background-color:#f0fff4}.hljs-deletion{color:#b31d28;background-color:#ffeef0}.hljs-char.escape_,.hljs-link,.hljs-params,.hljs-property,.hljs-punctuation,.hljs-tag{}
    </style>
</head>
<body>

<div class="content">
    <header class="site-header">
    <a href="/" class="home">Brian Douglas</a>

    <div class="svg-container">
        <a href="https://github.com/BrianDouglasIE" class="github">
            <svg
                height="32"
                aria-hidden="true"
                viewBox="0 0 24 24"
                width="32"
                data-view-component="true"
            >
                <path
                    d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"
                ></path>
            </svg>
        </a>

        <a
            href="https://linkedin.com/in/brian-douglas-90abb93ab"
            class="linkedin"
        >
            <svg
                viewBox="0 0 128 128"
                height="32"
                aria-hidden="true"
                width="32"
                data-view-component="true"
            >
                <path
                    d="M116 3H12a8.91 8.91 0 00-9 8.8v104.42a8.91 8.91 0 009 8.78h104a8.93 8.93 0 009-8.81V11.77A8.93 8.93 0 00116 3zM39.17 107H21.06V48.73h18.11zm-9-66.21a10.5 10.5 0 1110.49-10.5 10.5 10.5 0 01-10.54 10.48zM107 107H88.89V78.65c0-6.75-.12-15.44-9.41-15.44s-10.87 7.36-10.87 15V107H50.53V48.73h17.36v8h.24c2.42-4.58 8.32-9.41 17.13-9.41C103.6 47.28 107 59.35 107 75z"
                ></path>
            </svg>
        </a>
    </div>
</header>

    <div class="breadcrumbs">
        <a href="/">Home</a> / <span>Request cache in Spring</span>
    </div>

    <main>
        <article class="post">
            <header>
                <h1>Request cache in Spring</h1>
                <time datetime="19/05/2025">May 19th, 2025</time>
            </header>

            <div class="body">
                <p>Let's say we have a request that fetches a post stored in the database. That request may need
to alter the fetched post in some way. Before the post is altered various checks may need to
happen, such as an ownership check. But we want to avoid each check fetching the same post
from the database. This is when a cache that is scoped to a request's life cycle comes in handy.</p>
<!-- more -->
<p>In a <a href="/pre-auth-spring">previous post</a> I introduced a method for carrying out ownership checks
using Spring Security's <code>@PreAuthorize</code> annotation. Whilst the approach was clean and maintainable
it did introduce a performance issue. This is because <code>@PreAuthorize</code> executes before the method body. 
The post is fetched during the security check, and then again inside the method. This leads to duplicate 
fetches from the database. Once in the <code>isOwner</code> call and then again in the <code>findOwnedPost</code> call. You 
can see for yourself in the below code example.</p>
<pre class="java language-java"><code class="hljs java language-java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PostSecurity</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PostRepository postRepository;

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOwner</span><span class="hljs-params">(Long id, String userEmail)</span> {
        <span class="hljs-keyword">return</span> postRepository.findById(id) <span class="hljs-comment">// first fetch</span>
                .map(Post::getUser)
                .map(AppUser::getEmail)
                .map(it -&gt; it.equals(userEmail))
                .orElse(<span class="hljs-literal">false</span>);
    }
}
</code></pre>
<pre class="java language-java"><code class="hljs java language-java"><span class="hljs-meta">@PreAuthorize(&quot;@postSecurity.isOwner(#postId, authentication.name)&quot;)</span>
<span class="hljs-keyword">public</span> Post <span class="hljs-title function_">getOwnedPost</span><span class="hljs-params">(Long postId)</span> {
    <span class="hljs-keyword">return</span> postRepository.findById(postId) <span class="hljs-comment">// second fetch</span>
            .orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntityNotFoundException</span>(<span class="hljs-string">&quot;Post not found&quot;</span>));
}
</code></pre>
<p>One simple way to avoid this would be to do the ownership check inside the <code>getOwnedPost</code> method.
This may seem straightforward, but it would lead to code that is harder to maintain. For example
the authenticated <code>UserDetails</code> would need to be passed around, and a checked exceptions would need
added to each caller… yuck.</p>
<p>A nice solution would be to cache the owned post instance for the lifecycle of the request. This would
mean that the <code>isOwner</code> method would cache the post on look up. The post could then be retrieved from
the cache inside the <code>getOwnedPost</code> method. Meaning that there is only one post look up. We would then
add a request filter to clear the cache after each request.</p>
<h2 id="usingarequestbasedcache">Using a request based cache</h2>
<p>Each Spring request uses it's own thread. This means that we can cache values for the current request's
thread, without affecting any other request. To do this we'll use a plain old java object to model our
<code>RequestCache</code>. I want to use this solution for different entity types, so I'll make it generic by making 
it a generic class, so it can hold any type of entity.</p>
<pre class="java language-java"><code class="hljs java language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestCache</span>&lt;T&gt; {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Optional&lt;T&gt;&gt; holder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> {
        holder.set(Optional.ofNullable(value));
    }

    <span class="hljs-keyword">public</span> Optional&lt;T&gt; <span class="hljs-title function_">get</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> holder.get();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> {
        holder.remove();
    }
}
</code></pre>
<p><magpie-trinket>In some contexts like asynchronous processing, you may need <code>InheritableThreadLocal</code> or a 
more advanced request-scoped solution like Spring’s <code>@RequestScope</code>. But for typical synchronous requests, 
<code>ThreadLocal</code> works well.</magpie-trinket></p>
<p>Now let's create a <code>RequestCacheRegistry</code>. This will be a <code>@Component</code> to allow it to be injected into
the various services that will use it. You will be able to see at this stage how this approach can be
extended to work with various entities, by adding a unique <code>RequestCache</code> property for each cached item.</p>
<pre class="java language-java"><code class="hljs java language-java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestCacheRegistry</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> RequestCache&lt;Post&gt; ownedPost = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestCache</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearAll</span><span class="hljs-params">()</span> {
        ownedPost.clear();
    }
}
</code></pre>
<p>Now that our <code>RequestCacheRegistry</code> has been set up, we can use it within our <code>PostService</code>. First we'll
need to modify the <code>PostSecurity</code> component to cache the post that is returned from the <code>PostRepository</code>.
As the <code>PostRepository</code> returns an <code>Optional&lt;Post&gt;</code> the cache can be updated in a chained <code>map</code> call.</p>
<pre class="java language-java"><code class="hljs java language-java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PostSecurity</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PostRepository postRepository;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RequestCacheRegistry requestCacheRegistry;

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOwner</span><span class="hljs-params">(Long id, String userEmail)</span> {
        <span class="hljs-keyword">return</span> postRepository.findById(id)
                .filter(it -&gt; it.getUser().getEmail().equals(userEmail))
                .map(it -&gt; {
                    requestCacheRegistry.getOwnedPost().set(it); <span class="hljs-comment">// cache post</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                })
                .orElse(<span class="hljs-literal">false</span>);
    }
}
</code></pre>
<p>Now that the <code>requestCacheRegisty.ownedPost</code> is set. It can be access inside the <code>getOwnedPost</code> method that
has the <code>PreAuthorize</code> annotation.</p>
<pre class="java language-java"><code class="hljs java language-java"><span class="hljs-meta">@PreAuthorize(&quot;@postSecurity.isOwner(#postId, authentication.name)&quot;)</span>
<span class="hljs-keyword">public</span> Post <span class="hljs-title function_">getOwnedPost</span><span class="hljs-params">(Long postId)</span> {
    <span class="hljs-keyword">return</span> requestCacheRegistry.getOwnedPost().get().orElseGet(() -&gt; findById(postId));
}
</code></pre>
<p>With all this in place there is now only one database call to fetch the required post. We have also implemented
a pattern that will allow for other entities to be cached in the same way, using the <code>RequestCacheRegistry</code>.</p>
<h2 id="clearingthecache">Clearing the cache</h2>
<p>It is important that we clear the request cache after each request completes. This will help prevent any thread
leaks from occurring. A clean way of doing this is to implement a request filter. The following request filter
will be called automatically on each request. Once the filter chain completes, this custom filter will call
the <code>cacheRegistry.clearAll</code> method. Ensuring the cache registry is safely cleared after each request.</p>
<pre class="java language-java"><code class="hljs java language-java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestCacheCleanUpFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OncePerRequestFilter</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RequestCacheRegistry cacheRegistry;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)</span>
            <span class="hljs-keyword">throws</span> ServletException, IOException {
        <span class="hljs-keyword">try</span> {
            filterChain.doFilter(request, response);
        } <span class="hljs-keyword">finally</span> {
            cacheRegistry.clearAll();
        }
    }

}
</code></pre>
            </div>

            <footer>
                <p><i>Until next time,</i></p>
                <p><i>Brian</i></p>
            </footer>
        </article>
    </main>

    <footer class="site-footer">
    <p>
        <small>Since August 4th, 2023. All words by Brian
            Douglas. <a href="mailto:brianwdouglas@proton.me">Have a comment?</a></small>
    </p>
</footer>

</div>

<script src="/scripts/chicken-and-magpie.js"></script>
<script src="/scripts/skip-to-section.js"></script>
</body>
</html>
